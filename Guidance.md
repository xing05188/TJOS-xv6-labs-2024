# Lab guidance

## 作业难度说明

每个作业都会标明其难度：

- **简单**：少于一小时。通常是为后续练习做热身的练习。
- **中等**：1-2 小时。
- **困难**：超过 2 小时。这类练习通常代码量不大，但实现起来较为复杂。

这些时间只是大致预期。部分可选作业我们没有标准答案，难度仅为估算。如果你发现自己花费的时间远超预期，请在 piazza 上提问或来参加办公时间。

一般来说，练习所需代码行数不多（几十到几百行），但概念复杂，细节很重要。请务必完成实验相关的阅读，仔细阅读相关文件，查阅文档（RISC-V 手册等可在参考页面找到），再开始编写代码。建议将解决方案分解为小步骤（作业通常会给出分解建议），每完成一步就测试一次再继续。

**警告**：不要在截止前一晚才开始实验；分多天完成效率更高。操作系统内核中的 bug 可能表现诡异，排查和修复都需要耐心和细致的调试。

---

## 调试技巧

以下是一些调试建议：

- 确保你理解 C 语言和指针。推荐阅读《C 程序设计语言（第二版）》Kernighan 和 Ritchie 著。请理解示例代码的运行结果及原因。
- 一些常见指针用法值得记住：

    - 如果 `int *p = (int*)100`，那么 `(int)p + 1` 和 `(int)(p + 1)` 是不同的数：前者是 101，后者是 104。指针加整数时，整数会隐式乘以指针所指对象的大小。
    - `p[i]` 等价于 `*(p+i)`，表示指针 p 指向的第 i 个对象。上述加法规则保证了对象大于 1 字节时的正确寻址。
    - `&p[i]` 等价于 `(p+i)`，表示第 i 个对象的地址。
    - 虽然大多数 C 程序无需在指针和整数间转换，但操作系统开发中经常需要。遇到地址加法时，请确认是整数加法还是指针加法，并确保加数是否已乘以对象大小。

- 如果你的练习部分完成，建议用 Git 提交进度。若后续出错，可回滚到检查点，分步调试。想了解更多 Git 用法，可参考 Git 用户手册或面向 CS 的 Git 概览。
- 如果代码未通过测试，务必理解原因。多插入打印语句，直到弄清楚问题所在。
- 打印输出过多时，可用 `script` 命令记录所有控制台输出到文件，便于搜索。运行 `make qemu` 前先运行 `script`，结束后记得退出 `script`。
- 打印语句通常足够调试，但有时需要单步执行汇编或检查栈变量。调试 xv6 可在一个窗口运行 `make qemu-gdb`，另一个窗口运行 `gdb-multiarch`（或 `riscv64-linux-gnu-gdb`、`riscv64-unknown-elf-gdb`），设置断点后输入 `c`（继续），xv6 会运行到断点。更多 GDB 技巧见“使用 GNU 调试器”。如遇 `warning: File ".../.gdbinit" auto-loading has been declined`，按提示编辑 `~/.gdbinit` 添加 `add-auto-load-safe-path...`。
- 想查看编译器为 xv6 内核生成的汇编代码或定位某内核地址的指令，可查阅 `kernel/kernel.asm` 文件（Makefile 编译内核时生成）。所有用户程序也会生成对应的 `.asm` 文件。
- 如果内核异常崩溃（如访问非法内存），会打印包含程序计数器（sepc）的错误信息。可在 `kernel.asm` 中搜索该地址，或用 `addr2line -e kernel/kernel pc-value` 查找对应函数。需要回溯时，可用 gdb：一窗口运行 `make qemu-gdb`，另一窗口运行 gdb，设置 `panic` 断点（`b panic`），输入 `c`，内核到断点时输入 `bt` 查看回溯。
- 若内核死锁等原因导致卡死，可用 gdb 查找卡住位置。方法同上，内核卡住时在 qemu-gdb 窗口按 Ctrl-C，再输入 `bt` 查看回溯。
- qemu 提供“监控台”可查询虚拟机状态。按 `Ctrl-a c` 进入，常用命令如 `info mem` 可打印页表。可用 `cpu` 命令切换核心，或用 `make CPUS=1 qemu` 只启动一个核心。

**建议花时间学习上述工具的用法。**
